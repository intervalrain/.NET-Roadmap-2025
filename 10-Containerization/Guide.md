# Chapter 10.1: Container

## 前言

歡迎來到第十章！在現代軟體開發與部署中，你幾乎不可能避開一個核心概念：**容器 (Container)**。容器化技術徹底改變了我們建構、交付和執行應用程式的方式。在本章中，我們將深入了解容器是什麼，以及它為何如此重要。

## 解決了什麼問題？「在我電腦上可以跑」

在容器出現之前，開發人員經常面臨一個經典的難題：「這個程式在我的開發電腦上可以正常執行，為什麼在測試環境或生產環境就出錯了？」

這個問題通常源於 **環境不一致**：
- **作業系統差異**：開發用 Windows，部署用 Linux。
- **依賴版本不同**：開發環境的 .NET Runtime 版本、函式庫版本與生產環境不一致。
- **環境變數或設定檔遺失**：某些重要的設定只存在於開發人員的本機上。

這種不一致性導致了大量的時間浪費在環境的偵錯和修復上，而不是應用程式本身。

## 什麼是容器？

容器是一種輕量級、可執行的軟體套件，它將應用程式程式碼及其所有依賴（如執行時、系統工具、系統函式庫和設定）全部打包在一起。這個套件可以在任何地方以相同的方式執行，無論底層的環境如何。

**核心思想：將應用程式與其環境打包在一起。**

你可以將容器想像成一個標準化的「貨運集裝箱」。無論集裝箱裡面裝的是電視、香蕉還是汽車，集裝箱本身都可以被任何標準的起重機、貨車或輪船來處理。同樣地，無論容器裡裝的是 .NET 應用、Node.js 應用還是 Python 應用，容器本身都可以被任何標準的容器執行時（如 Docker）來執行。

## 容器 vs. 虛擬機器 (Virtual Machines)

為了更好地理解容器，我們常常將它與虛擬機器 (VM) 進行比較。

- **虛擬機器 (VM)**：VM 會虛擬化一整套硬體，然後在上面執行一個完整的「客體作業系統 (Guest OS)」。每個 VM 都有自己的核心、驅動程式和系統函式庫。這使得 VM 非常笨重（通常好幾個 GB），且啟動緩慢（需要幾分鐘）。

- **容器 (Container)**：容器則是在作業系統層級進行虛擬化。同一台主機上的所有容器 **共享主機的作業系統核心**。容器只打包了應用程式本身和它所需要的函式庫和設定（稱為使用者空間）。這使得容器極其輕量（通常只有幾十 MB），且啟動速度極快（秒級甚至毫秒級）。

![Container vs. VM](https://i.imgur.com/e5L4qY5.png)

## Docker：容器化的代名詞

當我們談論容器時，我們通常會提到 **Docker**。Docker 是一個開源的平台，它讓建立、管理和執行容器變得極其簡單。它主要由兩部分組成：

1.  **Dockerfile**：一個純文字檔案，它像一份「食譜」，定義了如何一步步地建構一個容器映像 (Image)。例如：
    - 從一個包含 .NET SDK 的基礎映像開始。
    - 將你的應用程式原始碼複製進去。
    - 執行 `dotnet publish` 來建構你的應用。
    - 設定容器啟動時要執行的命令。

2.  **容器映像 (Image)**：一個唯讀的範本，包含了執行應用程式所需的一切。你可以將映像推送到一個「註冊庫 (Registry)」（如 Docker Hub）中，與他人共享或在其他機器上部署。

3.  **容器 (Container)**：映像的一個可執行的實例。你可以從同一個映像啟動任意多個容器。

## 結語

容器化技術透過提供一個一致、可重複、可攜的執行環境，解決了軟體開發與部署中的一個核心痛點。它讓開發人員可以專注於撰寫程式碼，而維運人員則可以專注於管理標準化的容器，極大地促進了 DevOps 文化和微服務架構的發展。

在下一個章節，我們將學習如何使用 **Kubernetes**，一個強大的容器編排系統，來管理和擴展大規模的容器化應用。

---

# Chapter 10.2: Kubernetes

## 前言

當你的應用程式只有少數幾個容器時，手動管理它們（例如使用 `docker run`）是可行的。但當你的微服務應用由數十個甚至數百個容器組成時，你需要一個更強大的工具來自動化部署、擴展和管理這些容器。這就是 **容器編排 (Container Orchestration)** 工具的用武之地，而 **Kubernetes (常簡稱為 K8s)** 正是這個領域中事實上的標準。

## 什麼是 Kubernetes？

Kubernetes 是一個開源的容器編排平台，最初由 Google 設計並開源。它提供了一個框架，讓你能夠以聲明式 (declarative) 的方式來描述你希望應用程式達到的「期望狀態 (Desired State)」，然後 Kubernetes 會自動地工作，確保系統的「實際狀態」與你的期望狀態保持一致。

**Kubernetes 幫你解決的問題：**
- **服務發現與負載平衡**：如何讓一個容器找到並與另一個容器通訊？如何在多個相同的容器之間分配流量？
- **自動擴展 (Scaling)**：如何根據 CPU 使用率或其他指標，自動增加或減少容器的數量？
- **自我修復 (Self-healing)**：如果一個容器或它所在的機器發生故障，如何自動地重新啟動或替換它？
- **自動化部署與回滾**：如何以滾動更新 (rolling update) 的方式部署新版本的應用，而不會造成服務中斷？如果新版本有問題，如何快速地回滾到上一個穩定版本？
- **設定與密鑰管理**：如何管理應用程式的設定和敏感資訊（如資料庫密碼、API 金鑰）？

## Kubernetes 核心概念

理解 Kubernetes 需要掌握一些核心的物件概念：

1.  **Pod**：Pod 是 Kubernetes 中可以建立和管理的 **最小部署單元**。一個 Pod 通常包含一個應用程式容器，但也可以包含多個緊密相關的容器（它們會共享網路和儲存）。你可以將 Pod 想像成一個邏輯上的「主機」。

2.  **Deployment (部署)**：Deployment 用於描述你希望應用程式達到的期望狀態。你可以在 Deployment 中定義：
    - 要使用的容器映像。
    - 需要執行的 Pod 副本數量 (Replicas)。
    - 更新策略（例如滾動更新）。
    Kubernetes 會確保實際執行的 Pod 數量始終與你設定的副本數量相符。

3.  **Service (服務)**：Pod 的生命週期是短暫的，它們可能會因為故障或擴展而被銷毀和重建，導致其 IP 位址發生變化。**Service** 提供了一個穩定的入口點（一個固定的 IP 位址和 DNS 名稱），用於存取一組功能相同的 Pod。Service 會自動地將流量負載平衡到它背後的那些健康的 Pod 上。

4.  **ReplicaSet (副本集)**：這是 Deployment 底層使用的一個元件，它的唯一職責就是確保指定數量的 Pod 副本正在執行。

![Kubernetes Concepts](https://i.imgur.com/r1g2E8t.png)

## 結語

Kubernetes 是一個極其強大但也相當複雜的系統。它為管理大規模容器化應用提供了一套標準化、自動化的解決方案，是現代雲端原生應用開發的基石。雖然你可能不會每天都直接與 Kubernetes 的 API 互動，但理解其核心概念將有助於你更好地設計和部署你的微服務應用。

在下一個章節，我們將介紹 .NET 8 中一個令人興奮的新功能——**.NET Aspire**，它旨在簡化基於 Kubernetes 的雲端原生應用的開發體驗。

---

# Chapter 10.3: .NET Aspire

## 前言

我們已經了解了容器和 Kubernetes 如何幫助我們部署和管理分散式應用。然而，在 **開發階段**，設定和執行一個包含多個微服務、資料庫和訊息佇列的本地環境仍然非常複雜。開發人員需要處理 Docker Compose 檔案、設定服務發現、管理大量的設定和連線字串。為了解決這些痛點，Microsoft 在 .NET 8 中推出了一個全新的、有主見的 (opinionated) 雲端原生開發堆疊：**.NET Aspire**。

## 什麼是 .NET Aspire？

.NET Aspire **不是** 一個執行時框架，而是一個專為建構可觀測、可產品化、分散式的應用程式而設計的 **開發體驗** 增強工具集。它提供了一致的模式和工具，來簡化雲端原生應用的開發和除錯。

**核心目標：**
- **簡化本地開發協調 (Orchestration)**：讓你能夠輕鬆地在本地啟動和連接多個專案、容器和可執行檔。
- **內建服務發現**：自動處理服務之間的通訊，無需在設定檔中硬式編碼主機名稱和連接埠。
- **增強的可觀測性 (Observability)**：預設集成了 OpenTelemetry，自動為你的應用程式提供日誌、追蹤和指標，並提供一個強大的開發者儀表板來視覺化這些資料。
- **簡化的部署**：Aspire 專案可以產生部署資訊清單 (manifest)，簡化了將應用程式部署到 Azure 或 Kubernetes 的過程。

## .NET Aspire 的核心元件

一個典型的 .NET Aspire 解決方案包含三個主要部分：

1.  **`YourApp.AppHost`**
    這是一個 **協調專案**，它使用 C# 程式碼來描述你的應用程式是由哪些部分組成的。你可以在這裡定義你的微服務、資料庫容器、快取等，以及它們之間的關係。

    ```csharp
    var builder = DistributedApplication.CreateBuilder(args);

    // 新增一個 Redis 容器作為快取
    var cache = builder.AddRedis("cache");

    // 新增一個後端 Web API 專案，並將快取連線字串注入其中
    var apiservice = builder.AddProject<Projects.MyWebApp_ApiService>("apiservice")
                              .WithReference(cache);

    // 新增一個前端 Blazor 專案，並告訴它後端 API 的位址
    builder.AddProject<Projects.MyWebApp_Web>("webfrontend")
           .WithReference(apiservice);

    builder.Build().Run();
    ```

2.  **`YourApp.ServiceDefaults`**
    這是一個共享的專案，用於集中設定所有服務的通用功能，例如預設的健康檢查端點、日誌設定和 OpenTelemetry 設定。

3.  **開發者儀表板 (Developer Dashboard)**
    當你執行 `AppHost` 專案時，Aspire 會啟動一個本地的 Web 儀表板。在這裡，你可以：
    - 查看所有專案和容器的狀態和端點。
    - 查看即時的結構化日誌串流。
    - 查看分散式追蹤 (Distributed Traces)，了解一個請求如何在你的多個服務之間流動。
    - 查看應用程式的指標。

![.NET Aspire Dashboard](https://i.imgur.com/L3tA4fS.png)

## 結語

.NET Aspire 旨在解決雲端原生開發中的「最後一哩路」問題——即從單一專案到多個服務協同工作的複雜性。.NET Aspire 並沒有發明新的技術，而是將現有的最佳實踐（如 Docker, OpenTelemetry, 服務發現）巧妙地整合在一起，提供了一個順暢、高效的「內循環 (inner-loop)」開發體驗。

它讓開發人員可以更專注於業務邏輯，而不是被本地環境的複雜性所困擾，是 .NET 在雲端原生時代向前邁出的重要一步。